/*
 * This file was adapted from the tinyVars repository provided in class.
 * Original source: https://github.students.cs.ubc.ca/CPSC410-2024W-T2/tinyVars
 * Modifications have been made to implement the FileScript DSL.
 */

package parser;

import ast.*;
import ast.Number;
import org.antlr.v4.runtime.ParserRuleContext;

import java.util.ArrayList;
import java.util.List;

public class ParseTreeToASTVisitor extends FileScriptParserBaseVisitor<Node> {
    @Override
    public Program visitProgram(FileScriptParser.ProgramContext ctx) {
        List<StatementNode> stmts = new ArrayList<>();
        for (FileScriptParser.StmtContext s : ctx.stmt()) {
            stmts.add((StatementNode) s.accept(this));
        }
        return new Program(stmts);
    }

    @Override
    /* Start Code Generated by ChatGPT on 2025-01-31 */
    public StatementNode visitStmt(FileScriptParser.StmtContext ctx) {
        if (ctx.assign() != null) {
            return (StatementNode) ctx.assign().accept(this);
        } else if (ctx.if_() != null) {
            return (StatementNode) ctx.if_().accept(this);
        } else if (ctx.while_() != null) {
            return (StatementNode) ctx.while_().accept(this);
        } else if (ctx.fnCall() != null) {
            return (StatementNode) ctx.fnCall().accept(this);
        }
        return null;
    }
    /* End Code Generated by ChatGPT on 2025-01-31 */

    @Override
    public Assign visitAssign(FileScriptParser.AssignContext ctx) {
        return new Assign((IdentifierName) ctx.varname().accept(this), (ExpressionNode) ctx.exp().accept(this));
    }

    @Override
    public If visitIf(FileScriptParser.IfContext ctx) {
        List<StatementNode> then = new ArrayList<>();
        List<StatementNode> else_ = new ArrayList<>();
        for (FileScriptParser.StmtContext s : ctx.block(0).stmt()) {
            then.add((StatementNode) s.accept(this));
        }
        if (ctx.ELSE() != null && ctx.block(1) != null) {
            for (FileScriptParser.StmtContext s : ctx.block(1).stmt()) {
                else_.add((StatementNode) s.accept(this));
            }
        }
        return new If((ExpressionNode) ctx.exp().accept(this), then, else_);
    }

    @Override
    public Index visitIndex(FileScriptParser.IndexContext ctx) {
        return new Index((ExpressionNode) ctx.exp().accept(this));
    }

    @Override
    public While visitWhile(FileScriptParser.WhileContext ctx) {
        List<StatementNode> do_ = new ArrayList<>();
        for (FileScriptParser.StmtContext s : ctx.block().stmt()) {
            do_.add((StatementNode) s.accept(this));
        }
        return new While((ExpressionNode) ctx.exp().accept(this), do_);
    }

    @Override
    public ExpressionNode visitExp(FileScriptParser.ExpContext ctx) {
        return (ExpressionNode) ctx.orExp().accept(this);
    }

    @Override
    public ExpressionNode visitOrExp(FileScriptParser.OrExpContext ctx) {
        return buildBinExp(ctx, ctx.andExp());
    }

    @Override
    public ExpressionNode visitAndExp(FileScriptParser.AndExpContext ctx) {
        return buildBinExp(ctx, ctx.relExp());
    }

    @Override
    public ExpressionNode visitRelExp(FileScriptParser.RelExpContext ctx) {
        return buildBinExp(ctx, ctx.addExp());
    }

    @Override
    public ExpressionNode visitAddExp(FileScriptParser.AddExpContext ctx) {
        return buildBinExp(ctx, ctx.mulExp());
    }

    @Override
    public ExpressionNode visitMulExp(FileScriptParser.MulExpContext ctx) {
        return buildBinExp(ctx, ctx.baseExp());
    }

    @Override
    public ExpressionNode visitBaseExp(FileScriptParser.BaseExpContext ctx) {
        if (ctx.NUM() != null) {
            return new Number(Integer.parseInt(ctx.NUM().getText()));
        } else if (ctx.TRUE() != null) {
            return new BooleanLiteral(true);
        } else if (ctx.FALSE() != null) {
            return new BooleanLiteral(false);
        } else if (ctx.TEXT() != null) {
            // Strip surrounding single quotes from the internal representations
            String textValue = ctx.TEXT().getText();
            textValue = textValue.substring(1, textValue.length() - 1);
            return new Text(textValue);
        } else if (ctx.varname() != null) {
            return (IdentifierName) ctx.varname().accept(this);
        } else if (ctx.fnCallExp() != null) {
            return (ExpressionNode) ctx.fnCallExp().accept(this);
        } else if (ctx.stack() != null) {
            return (ExpressionNode) ctx.stack().accept(this);
        }
        return null;
    }

    @Override
    public FnCallExp visitFnCallExp(FileScriptParser.FnCallExpContext ctx) {
        List<ExpressionNode> args = new ArrayList<>();
        if (ctx.fnCall().args() != null) {
            for (FileScriptParser.ExpContext e : ctx.fnCall().args().exp()) {
                args.add((ExpressionNode) e.accept(this));
            }
        }
        return new FnCallExp((IdentifierName) ctx.fnCall().fnName().accept(this), args);
    }

    @Override
    public FnCall visitFnCall(FileScriptParser.FnCallContext ctx) {
        List<ExpressionNode> args = new ArrayList<>();
        if (ctx.args() != null) {
            for (FileScriptParser.ExpContext e : ctx.args().exp()) {
                args.add((ExpressionNode) e.accept(this));
            }
        }
        return new FnCall((IdentifierName) ctx.fnName().accept(this), args);
    }

    @Override
    public IdentifierName visitFnName(FileScriptParser.FnNameContext ctx) {
        return new IdentifierName(ctx.getText());
    }

    @Override
    public IdentifierName visitVarname(FileScriptParser.VarnameContext ctx) {
        String varName = ctx.NAME().getText();

        if (ctx.index() == null) {
            return new IdentifierName(varName);
        } else {
            Index index = (Index) ctx.index().accept(this);
            return new IdentifierName(varName, index);
        }
    }

    @Override
    public Tables visitStack(FileScriptParser.StackContext ctx) {
        return new Tables(null);
    }

    /* Start Code Generated by ChatGPT on 2025-01-31 */
    private ExpressionNode buildBinExp(ParserRuleContext ctx, List<? extends ParserRuleContext> operands) {
        ExpressionNode left = (ExpressionNode) operands.get(0).accept(this);
        for (int i = 1; i < operands.size(); i++) {
            left = new BinExp(left, ctx.getChild(2 * i - 1).getText(), (ExpressionNode) operands.get(i).accept(this));
        }
        return left;
    }
    /* End Code Generated by ChatGPT on 2025-01-31 */

}
